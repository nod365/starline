<!DOCTYPE html>
<html lang="ru">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Анализатор CSV Call-Center — расширенный</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            background-color: #f5f5f5;
        }

        .container {
            background-color: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
        }

        h1 {
            color: #333;
            text-align: center;
        }

        .upload-section {
            margin: 20px 0;
            padding: 15px;
            background-color: #f0f0f0;
            border-radius: 5px;
            text-align: center;
        }

        .date-range {
            margin: 10px 0;
            font-weight: bold;
            color: #555;
        }

        table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 20px;
        }

        th,
        td {
            border: 1px solid #ddd;
            padding: 10px;
            text-align: left;
        }


        th {
            background-color: #4CAF50;
            color: white;
        }

        tr:nth-child(even) {
            background-color: #f2f2f2;
        }

        .total-row {
            font-weight: bold;
            background-color: #e0e0e0;
        }

        .percent {
            font-size: 0.9em;
            color: #666;
        }

        .subblock {
            background: #fafafa;
            border-left: 4px solid #4CAF50;
            padding: 10px;
            margin: 8px 0 16px 0;
        }

        .small {
            font-size: 0.9em;
            color: #444;
        }

        button {
            background-color: #4CAF50;
            color: white;
            padding: 10px 20px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 16px;
        }

        button:hover {
            background-color: #45a049;
        }

        .info {
            margin-top: 20px;
            padding: 10px;
            background-color: #e7f3ff;
            border-radius: 5px;
        }

        * {
            font-size: 20px;
        }

        .small {
            font-size: 24px;
        }

        .small strong,
        .small .percent {
            font-size: 16px;
        }
    </style>
</head>

<body>
    <div class="container">
        <h1>Анализатор CSV для Call-Center групп (расширенный)</h1>

        <div class="upload-section">
            <input type="file" id="csvFile" accept=".csv">
            <button onclick="loadCSV()">Загрузить и проанализировать CSV</button>
            <p class="small">Кодировка: Windows-1251 (если CSV в другой кодировке — заранее перекодируйте)</p>
        </div>

        <div id="dateRange" class="date-range"></div>

        <div id="tableContainer"></div>

        <div class="info">
            <p><strong>Целевые группы:</strong> Call - Center, Call - Center [ДТП], Call - Center [Поломки], Call -
                Center [ГИБДД], КОНТРОЛЬ КАЧЕСТВА</p>
            <p class="small">Программа использует только итоговые строки — те, где значение в колонке "Дата" совпадает с
                названием группы (это ваша "итоговая" строка).</p>
        </div>
    </div>

    <script>
        const targetGroups = [
            "Call - Center",
            "Call - Center [ДТП]",
            "Call - Center [Поломки]",
            "Call - Center [ГИБДД]",
            "КОНТРОЛЬ КАЧЕСТВА"
        ];

        function loadCSV() {
            const fileInput = document.getElementById('csvFile');
            const file = fileInput.files[0];

            if (!file) {
                alert('Пожалуйста, выберите CSV файл');
                return;
            }

            const reader = new FileReader();

            reader.onload = function (e) {
                const contents = e.target.result;
                processCSV(contents);
            };

            reader.readAsText(file, 'Windows-1251');
        }

        function processCSV(csvText) {
            const lines = csvText.split('\n');
            const data = [];

            for (let i = 0; i < lines.length; i++) {
                const line = lines[i].trim();
                if (line) {
                    const row = parseCSVLine(line);
                    data.push(row);
                }
            }

            if (data.length < 2) {
                alert('CSV файл пуст или содержит недостаточно данных');
                return;
            }

            const headers = data[0].map(h => h.replace(/"/g, '').trim());
            const groupIndex = headers.indexOf('Группа');
            const dateIndex = headers.indexOf('Дата');
            const acceptedIndex = headers.indexOf('Количество принятых вызовов');
            const completedIndex = headers.indexOf('Количество совершенных вызовов');
            const missedIndex = headers.indexOf('Количество пропущенных вызовов');

            if (groupIndex === -1 || dateIndex === -1) {
                alert('CSV файл не содержит необходимых колонок (Группа, Дата)');
                return;
            }

            // Собираем только итоговые строки (где Группа === Дата)
            const finalRows = [];
            const allDates = [];

            for (let i = 1; i < data.length; i++) {
                const row = data[i];
                if (row.length <= Math.max(groupIndex, dateIndex)) continue;
                const group = (row[groupIndex] || '').replace(/"/g, '').trim();
                const date = (row[dateIndex] || '').replace(/"/g, '').trim();

                // Сохраняем даты для определения диапазона
                if (group && /^\d{2}\.\d{2}\.\d{4}$/.test(date)) {
                    allDates.push(date);
                }

                // ТОЛЬКО строки где Группа === Дата
                if (group && date && group === date) {
                    const accepted = acceptedIndex !== -1 ? parseInt((row[acceptedIndex] || '0').replace(/"/g, '')) || 0 : 0;
                    const completed = completedIndex !== -1 ? parseInt((row[completedIndex] || '0').replace(/"/g, '')) || 0 : 0;
                    const missed = missedIndex !== -1 ? parseInt((row[missedIndex] || '0').replace(/"/g, '')) || 0 : 0;
                    finalRows.push({ group, accepted, completed, missed });
                }
            }

            // Находим диапазон дат
            let minDate = null, maxDate = null;
            if (allDates.length > 0) {
                const dateObjects = allDates.map(dateStr => {
                    const [d, m, y] = dateStr.split('.');
                    return new Date(y, m - 1, d);
                });
                minDate = new Date(Math.min(...dateObjects));
                maxDate = new Date(Math.max(...dateObjects));
            }

            const dateRangeElement = document.getElementById('dateRange');
            if (minDate && maxDate) {
                const formatDate = d => `${String(d.getDate()).padStart(2, '0')}.${String(d.getMonth() + 1).padStart(2, '0')}.${d.getFullYear()}`;
                dateRangeElement.textContent = `Отчет с ${formatDate(minDate)} по ${formatDate(maxDate)}`;
            } else {
                dateRangeElement.textContent = 'Диапазон дат не определен';
            }

            // Собираем данные по целевым группам ТОЛЬКО из итоговых строк
            const groupData = {};
            for (const t of targetGroups) groupData[t] = { accepted: 0, completed: 0, missed: 0 };

            // Прочие итоговые строки (не целевые)
            const others = [];

            // Обрабатываем ТОЛЬКО итоговые строки (где group === date)
            for (const row of finalRows) {
                if (targetGroups.includes(row.group)) {
                    groupData[row.group] = {
                        accepted: row.accepted,
                        completed: row.completed,
                        missed: row.missed
                    };
                } else {
                    others.push(row);
                }
            }

            // Общие итоги
            let totalAccepted = 0, totalCompleted = 0, totalMissed = 0;
            for (const g of Object.keys(groupData)) {
                totalAccepted += groupData[g].accepted;
                totalCompleted += groupData[g].completed;
                totalMissed += groupData[g].missed;
            }

            // Сбор подкатегорий для Call - Center
            const callCenterName = 'Call - Center';
            const callCenter = groupData[callCenterName] || { accepted: 0, completed: 0, missed: 0 };

            // Критерии для подкатегорий Call-Center
            const reports = { accepted: 0, completed: 0, missed: 0 };
            const dispatchers = { accepted: 0, completed: 0, missed: 0 };
            const othersForCall = { accepted: 0, completed: 0, missed: 0 };

            // Отделы для категории "Соединены с другими"
            const otherDepartments = ['оформл', 'сервис', 'админ', 'обл'];

            // Рассматриваем ТОЛЬКО те строки из others, которые:
            // 1. Являются итоговыми (уже проверено выше)
            // 2. Не входят в targetGroups (уже отфильтровано)
            for (const row of others) {
                const nameLower = row.group.toLowerCase();

                if (nameLower.includes('отчет')) {
                    reports.accepted += row.accepted;
                    reports.completed += row.completed;
                    reports.missed += row.missed;
                } else if (nameLower.includes('диспетч')) {
                    dispatchers.accepted += row.accepted;
                    dispatchers.completed += row.completed;
                    dispatchers.missed += row.missed;
                } else {
                    // Проверяем, содержит ли название один из указанных отделов
                    let isOtherDepartment = false;
                    for (const dept of otherDepartments) {
                        if (nameLower.includes(dept)) {
                            isOtherDepartment = true;
                            break;
                        }
                    }

                    if (isOtherDepartment) {
                        othersForCall.accepted += row.accepted;
                        othersForCall.completed += row.completed;
                        othersForCall.missed += row.missed;
                    }
                    // Если не является ни отчетом, ни диспетчером, ни указанным отделом - игнорируем
                }
            }

            // 'Решили сами' = то, что осталось в Call - Center после вычитания перечисленных подгрупп
            const resolvedBySelf = {
                accepted: Math.max(0, callCenter.accepted - (reports.accepted + dispatchers.accepted + othersForCall.accepted)),
                completed: Math.max(0, callCenter.completed - (reports.completed + dispatchers.completed + othersForCall.completed)),
                missed: Math.max(0, callCenter.missed - (reports.missed + dispatchers.missed + othersForCall.missed))
            };

            // Готовим структуру для отображения
            const displayOrder = [];
            if (groupData[callCenterName]) displayOrder.push({ name: callCenterName, data: groupData[callCenterName] });

            // Подкатегории Call-Center
            const callSub = [
                { name: 'Соединены на отчетников', data: reports },
                { name: 'Соединены на диспетчеров', data: dispatchers },
                { name: 'Соединены с другими (Оформление/Сервис/Админ/Обл.)', data: othersForCall },
                { name: 'Решили сами, не переключали', data: resolvedBySelf }
            ];

            // Добавляем остальные целевые группы
            for (const t of targetGroups) {
                if (t === callCenterName) continue;
                if (groupData[t]) displayOrder.push({ name: t, data: groupData[t] });
            }

            // Создаём таблицу
            createTable({ displayOrder, callSub, totals: { totalAccepted, totalCompleted, totalMissed } });
        }

        function parseCSVLine(line) {
            const result = [];
            let current = '';
            let inQuotes = false;

            for (let i = 0; i < line.length; i++) {
                const char = line[i];
                if (char === '"') {
                    inQuotes = !inQuotes;
                } else if (char === ';' && !inQuotes) {
                    result.push(current);
                    current = '';
                } else {
                    current += char;
                }
            }

            result.push(current);
            return result;
        }

        function createTable({ displayOrder, callSub, totals }) {
            const tableContainer = document.getElementById('tableContainer');
            tableContainer.innerHTML = '';

            const table = document.createElement('table');

            // Заголовки
            const header = document.createElement('tr');
            header.innerHTML = `<th>Группа</th><th>Принято ↓</th><th>Совершено</th><th>Пропущено</th>`;
            table.appendChild(header);

            // Функция подсчёта процентов от общего (totals) — для строк кроме Call - Center подкатегорий
            const totalAccepted = totals.totalAccepted;
            const totalCompleted = totals.totalCompleted;
            const totalMissed = totals.totalMissed;

            for (const item of displayOrder) {
                const row = document.createElement('tr');
                const acceptedPercent = totalAccepted > 0 ? ((item.data.accepted / totalAccepted) * 100).toFixed(1) : '0.0';
                const completedPercent = totalCompleted > 0 ? ((item.data.completed / totalCompleted) * 100).toFixed(1) : '0.0';
                const missedPercent = totalMissed > 0 ? ((item.data.missed / totalMissed) * 100).toFixed(1) : '0.0';

                row.innerHTML = `
					<td>${item.name}</td>
					<td>${item.data.accepted} <span class="percent">(${acceptedPercent}%)</span></td>
					<td>${item.data.completed} <span class="percent">(${completedPercent}%)</span></td>
					<td>${item.data.missed} <span class="percent">(${missedPercent}%)</span></td>
				`;
                table.appendChild(row);

                // Если это Call - Center — добавляем подкатегории прямо под ней
                if (item.name === 'Call - Center') {
                    const callAcceptedBase = item.data.accepted || 0;
                    const callCompletedBase = item.data.completed || 0;
                    const callMissedBase = item.data.missed || 0;

                    const subBlockRow = document.createElement('tr');
                    subBlockRow.innerHTML = `<td colspan="4">
						<div class="subblock">
							<strong>ИЗ НИХ (проценты от Call - Center):</strong>
							<div id="callSubContainer"></div>
						</div>
					</td>`;
                    table.appendChild(subBlockRow);

                    // Вставим строки подкатегорий в контейнер
                    const container = subBlockRow.querySelector('#callSubContainer');
                    for (const sub of callSub) {
                        const a = sub.data.accepted || 0;
                        const c = sub.data.completed || 0;
                        const m = sub.data.missed || 0;
                        const aPct = callAcceptedBase > 0 ? ((a / callAcceptedBase) * 100).toFixed(1) : '0.0';
                        const cPct = callCompletedBase > 0 ? ((c / callCompletedBase) * 100).toFixed(1) : '0.0';
                        const mPct = callMissedBase > 0 ? ((m / callMissedBase) * 100).toFixed(1) : '0.0';

                        const line = document.createElement('div');
                        line.className = 'small';
                        line.innerHTML = `
							<strong>${sub.name}</strong>: ${a} <span class="percent">(${aPct}% принятых)</span></span>
						`;
                        container.appendChild(line);
                    }
                }
            }

            // Итоговая строка
            const totalRow = document.createElement('tr');
            totalRow.className = 'total-row';
            totalRow.innerHTML = `
				<td><strong>ИТОГО</strong></td>
				<td><strong>${totalAccepted}</strong></td>
				<td><strong>${totalCompleted}</strong></td>
				<td><strong>${totalMissed}</strong></td>
			`;
            table.appendChild(totalRow);

            tableContainer.appendChild(table);
        }
    </script>
</body>

</html>